/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/lib/canvasRenderingContext2DExtensions.js":
/*!******************************************************!*\
  !*** ./js/lib/canvasRenderingContext2DExtensions.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("CanvasRenderingContext2D.prototype.storeLoadedImage = function (key, image) {\n  if (!this.images) {\n    this.images = {};\n  }\n\n  this.images[key] = image;\n};\n\nCanvasRenderingContext2D.prototype.getLoadedImage = function (key) {\n  if (this.images[key]) {\n    return this.images[key];\n  }\n};\n\nCanvasRenderingContext2D.prototype.followSprite = function (sprite) {\n  this.centralSprite = sprite;\n};\n\nCanvasRenderingContext2D.prototype.getCentralPosition = function () {\n  return {\n    map: this.centralSprite.mapPosition,\n    canvas: [Math.round(this.canvas.width * 0.5), Math.round(this.canvas.height * 0.5), 0]\n  };\n};\n\nCanvasRenderingContext2D.prototype.mapPositionToCanvasPosition = function (position) {\n  var central = this.getCentralPosition();\n  var centralMapPosition = central.map;\n  var centralCanvasPosition = central.canvas;\n  var mapDifferenceX = centralMapPosition[0] - position[0];\n  var mapDifferenceY = centralMapPosition[1] - position[1];\n  return [centralCanvasPosition[0] - mapDifferenceX, centralCanvasPosition[1] - mapDifferenceY];\n};\n\nCanvasRenderingContext2D.prototype.canvasPositionToMapPosition = function (position) {\n  var central = this.getCentralPosition();\n  var centralMapPosition = central.map;\n  var centralCanvasPosition = central.canvas;\n  var mapDifferenceX = centralCanvasPosition[0] - position[0];\n  var mapDifferenceY = centralCanvasPosition[1] - position[1];\n  return [centralMapPosition[0] - mapDifferenceX, centralMapPosition[1] - mapDifferenceY];\n};\n\nCanvasRenderingContext2D.prototype.getCentreOfViewport = function () {\n  return (this.canvas.width / 2).floor();\n}; // Y-pos canvas functions\n\n\nCanvasRenderingContext2D.prototype.getMiddleOfViewport = function () {\n  return (this.canvas.height / 2).floor();\n};\n\nCanvasRenderingContext2D.prototype.getBelowViewport = function () {\n  return this.canvas.height.floor();\n};\n\nCanvasRenderingContext2D.prototype.getMapBelowViewport = function () {\n  var below = this.getBelowViewport();\n  return this.canvasPositionToMapPosition([0, below])[1];\n};\n\nCanvasRenderingContext2D.prototype.getRandomlyInTheCentreOfCanvas = function (buffer) {\n  var min = 0;\n  var max = this.canvas.width;\n\n  if (buffer) {\n    min -= buffer;\n    max += buffer;\n  }\n\n  return Number.random(min, max);\n};\n\nCanvasRenderingContext2D.prototype.getRandomlyInTheCentreOfMap = function (buffer) {\n  var random = this.getRandomlyInTheCentreOfCanvas(buffer);\n  return this.canvasPositionToMapPosition([random, 0])[0];\n};\n\nCanvasRenderingContext2D.prototype.getRandomMapPositionBelowViewport = function () {\n  var xCanvas = this.getRandomlyInTheCentreOfCanvas();\n  var yCanvas = this.getBelowViewport();\n  return this.canvasPositionToMapPosition([xCanvas, yCanvas]);\n};\n\nCanvasRenderingContext2D.prototype.getRandomMapPositionAboveViewport = function () {\n  var xCanvas = this.getRandomlyInTheCentreOfCanvas();\n  var yCanvas = this.getAboveViewport();\n  return this.canvasPositionToMapPosition([xCanvas, yCanvas]);\n};\n\nCanvasRenderingContext2D.prototype.getTopOfViewport = function () {\n  return this.canvasPositionToMapPosition([0, 0])[1];\n};\n\nCanvasRenderingContext2D.prototype.getAboveViewport = function () {\n  return 0 - (this.canvas.height / 4).floor();\n};\n\n//# sourceURL=webpack:///./js/lib/canvasRenderingContext2DExtensions.js?");

/***/ }),

/***/ "./js/lib/extenders.js":
/*!*****************************!*\
  !*** ./js/lib/extenders.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Extends function so that new-able objects can be given new methods easily\nFunction.prototype.method = function (name, func) {\n  this.prototype[name] = func;\n  return this;\n}; // Will return the original method of an object when inheriting from another\n\n\nObject.method('superior', function (name) {\n  var that = this;\n  var method = that[name];\n  return function () {\n    return method.apply(that, arguments);\n  };\n});\n\n//# sourceURL=webpack:///./js/lib/extenders.js?");

/***/ }),

/***/ "./js/lib/game.js":
/*!************************!*\
  !*** ./js/lib/game.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _spriteArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spriteArray */ \"./js/lib/spriteArray.js\");\n/* harmony import */ var eventedloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventedloop */ \"./node_modules/eventedloop/lib/main.js\");\n/* harmony import */ var eventedloop__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eventedloop__WEBPACK_IMPORTED_MODULE_1__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar Game =\n/*#__PURE__*/\nfunction () {\n  function Game(mainCanvas, player) {\n    _classCallCheck(this, Game);\n\n    this.mainCanvas = mainCanvas;\n    this.player = player;\n    this.staticObjects = new _spriteArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.movingObjects = new _spriteArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.uiElements = new _spriteArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.dContext = this.mainCanvas.getContext('2d');\n    this.mouseX = this.dContext.getCentreOfViewport();\n    this.mouseY = 0;\n    this.paused = false;\n    this.beforeCycleCallbacks = [];\n    this.afterCycleCallbacks = [];\n    this.gameLoop = new eventedloop__WEBPACK_IMPORTED_MODULE_1___default.a();\n    this.player.setMapPosition(0, 0);\n    this.player.setMapPositionTarget(0, -10);\n    this.dContext.followSprite(this.player);\n    this.intervalNum = 0;\n    this.gameLoop.on('20', this.cycle.bind(this));\n    this.gameLoop.on('20', this.draw.bind(this));\n  }\n\n  _createClass(Game, [{\n    key: \"addStaticObject\",\n    value: function addStaticObject(sprite) {\n      this.staticObjects.push(sprite);\n    }\n  }, {\n    key: \"addStaticObjects\",\n    value: function addStaticObjects(sprites) {\n      sprites.forEach(this.addStaticObject.bind(this));\n    }\n  }, {\n    key: \"addMovingObject\",\n    value: function addMovingObject(movingObject, movingObjectType) {\n      if (movingObjectType) {\n        this.staticObjects.onPush(function (obj) {\n          if (obj.data && obj.data.hitBehaviour[movingObjectType]) {\n            obj.onHitting(movingObject, obj.data.hitBehaviour[movingObjectType]);\n          }\n        }, true);\n      }\n\n      this.movingObjects.push(movingObject);\n    }\n  }, {\n    key: \"addUIElement\",\n    value: function addUIElement(element) {\n      this.uiElements.push(element);\n    }\n  }, {\n    key: \"beforeCycle\",\n    value: function beforeCycle(callback) {\n      this.beforeCycleCallbacks.push(callback);\n    }\n  }, {\n    key: \"afterCycle\",\n    value: function afterCycle(callback) {\n      this.afterCycleCallbacks.push(callback);\n    }\n  }, {\n    key: \"setMouseX\",\n    value: function setMouseX(x) {\n      this.mouseX = x;\n    }\n  }, {\n    key: \"setMouseY\",\n    value: function setMouseY(y) {\n      this.mouseY = y;\n    }\n  }, {\n    key: \"cycle\",\n    value: function cycle() {\n      var _this = this;\n\n      this.beforeCycleCallbacks.each(function (c) {\n        c();\n      }); // Clear canvas\n\n      var mouseMapPosition = this.dContext.canvasPositionToMapPosition([this.mouseX, this.mouseY]);\n\n      if (!this.player.isJumping) {\n        this.player.setMapPositionTarget(mouseMapPosition[0], mouseMapPosition[1]);\n      }\n\n      this.intervalNum++;\n      this.player.cycle();\n      this.movingObjects.each(function (movingObject) {\n        movingObject.cycle(_this.dContext);\n      });\n      this.staticObjects.cull();\n      this.staticObjects.each(function (staticObject) {\n        if (staticObject.cycle) {\n          staticObject.cycle();\n        }\n      });\n      this.uiElements.each(function (uiElement) {\n        if (uiElement.cycle) {\n          uiElement.cycle();\n        }\n      });\n      this.afterCycleCallbacks.each(function (c) {\n        c();\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var _this2 = this;\n\n      // Clear canvas\n      this.mainCanvas.width = this.mainCanvas.width;\n      this.player.draw(this.dContext);\n      this.player.cycle();\n      this.movingObjects.each(function (movingObject, i) {\n        movingObject.draw(_this2.dContext);\n      });\n      this.staticObjects.each(function (staticObject, i) {\n        if (staticObject.draw) {\n          staticObject.draw(_this2.dContext, 'main');\n        }\n      });\n      this.uiElements.each(function (uiElement, i) {\n        if (uiElement.draw) {\n          uiElement.draw(_this2.dContext, 'main');\n        }\n      });\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.gameLoop.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n      this.gameLoop.stop();\n    }\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return this.paused;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      paused = false;\n      staticObjects = new _spriteArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      movingObjects = new _spriteArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n      mouseX = dContext.getCentreOfViewport();\n      mouseY = 0;\n      player.reset();\n      player.setMapPosition(0, 0, 0);\n      this.start();\n    }\n  }]);\n\n  return Game;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack:///./js/lib/game.js?");

/***/ }),

/***/ "./js/lib/guid.js":
/*!************************!*\
  !*** ./js/lib/guid.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Creates a random ID string\n(function (global) {\n  function guid() {\n    var S4 = function S4() {\n      return Math.floor(Math.random() * 0x10000\n      /* 65536 */\n      ).toString(16);\n    };\n\n    return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\n  }\n\n  global.guid = guid;\n})(this);\n\nif (true) {\n  module.exports = this.guid;\n}\n\n//# sourceURL=webpack:///./js/lib/guid.js?");

/***/ }),

/***/ "./js/lib/infoBox.js":
/*!***************************!*\
  !*** ./js/lib/infoBox.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function InfoBox(data) {\n  var that = this;\n  that.lines = data.initialLines;\n  that.top = data.position.top;\n  that.right = data.position.right;\n  that.bottom = data.position.bottom;\n  that.left = data.position.left;\n  that.width = data.width;\n  that.height = data.height;\n\n  that.setLines = function (lines) {\n    that.lines = lines;\n  };\n\n  that.draw = function (dContext) {\n    dContext.font = '11px monospace';\n    var yOffset = 0;\n    that.lines.each(function (line) {\n      var fontSize = +dContext.font.slice(0, 2);\n      var textWidth = dContext.measureText(line).width;\n      var textHeight = fontSize * 1.5;\n      var xPos, yPos;\n\n      if (that.top) {\n        yPos = that.top + yOffset;\n      } else if (that.bottom) {\n        yPos = dContext.canvas.height - that.top - textHeight + yOffset;\n      }\n\n      if (that.right) {\n        xPos = dContext.canvas.width - that.right - textWidth;\n      } else if (that.left) {\n        xPos = that.left;\n      }\n\n      yOffset += textHeight;\n      dContext.fillText(line, xPos, yPos);\n    });\n  };\n\n  return that;\n}\n\nif (true) {\n  module.exports = InfoBox;\n}\n\n//# sourceURL=webpack:///./js/lib/infoBox.js?");

/***/ }),

/***/ "./js/lib/isMobileDevice.js":
/*!**********************************!*\
  !*** ./js/lib/isMobileDevice.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function isMobileDevice() {\n  if (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Windows Phone/i)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = isMobileDevice;\n\n//# sourceURL=webpack:///./js/lib/isMobileDevice.js?");

/***/ }),

/***/ "./js/lib/monster.js":
/*!***************************!*\
  !*** ./js/lib/monster.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Sprite = __webpack_require__(/*! ./sprite */ \"./js/lib/sprite.js\");\n\n(function (global) {\n  function Monster(data) {\n    var that = new Sprite(data);\n    var super_draw = that.superior('draw');\n    var spriteVersion = 1;\n    var eatingStage = 0;\n    var standardSpeed = 6;\n    that.isEating = false;\n    that.isFull = false;\n    that.setSpeed(standardSpeed);\n\n    that.draw = function (dContext) {\n      var spritePartToUse = function spritePartToUse() {\n        var xDiff = that.movingToward[0] - that.canvasX;\n\n        if (that.isEating) {\n          return 'eating' + eatingStage;\n        }\n\n        if (spriteVersion + 0.1 > 2) {\n          spriteVersion = 0.1;\n        } else {\n          spriteVersion += 0.1;\n        }\n\n        if (xDiff >= 0) {\n          return 'sEast' + Math.ceil(spriteVersion);\n        } else if (xDiff < 0) {\n          return 'sWest' + Math.ceil(spriteVersion);\n        }\n      };\n\n      return super_draw(dContext, spritePartToUse());\n    };\n\n    function startEating(whenDone) {\n      eatingStage += 1;\n      that.isEating = true;\n      that.isMoving = false;\n\n      if (eatingStage < 6) {\n        setTimeout(function () {\n          startEating(whenDone);\n        }, 300);\n      } else {\n        eatingStage = 0;\n        that.isEating = false;\n        that.isMoving = true;\n        whenDone();\n      }\n    }\n\n    that.startEating = startEating;\n    return that;\n  }\n\n  global.monster = Monster;\n})(this);\n\nif (true) {\n  module.exports = this.monster;\n}\n\n//# sourceURL=webpack:///./js/lib/monster.js?");

/***/ }),

/***/ "./js/lib/plugins.js":
/*!***************************!*\
  !*** ./js/lib/plugins.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Avoid `console` errors in browsers that lack a console.\n(function () {\n  var method;\n\n  var noop = function noop() {};\n\n  var methods = ['assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error', 'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd', 'timeStamp', 'trace', 'warn'];\n  var length = methods.length;\n  var console = window.console = window.console || {};\n\n  while (length--) {\n    method = methods[length]; // Only stub undefined methods.\n\n    if (!console[method]) {\n      console[method] = noop;\n    }\n  }\n})();\n\n//# sourceURL=webpack:///./js/lib/plugins.js?");

/***/ }),

/***/ "./js/lib/skier.js":
/*!*************************!*\
  !*** ./js/lib/skier.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Sprite = __webpack_require__(/*! ./sprite */ \"./js/lib/sprite.js\");\n\nif (typeof navigator !== 'undefined') {\n  navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\n} else {\n  navigator = {\n    vibrate: false\n  };\n}\n\n(function (global) {\n  function Skier(data) {\n    var discreteDirections = {\n      'west': 270,\n      'wsWest': 240,\n      'sWest': 195,\n      'south': 180,\n      'sEast': 165,\n      'esEast': 120,\n      'east': 90\n    };\n    var that = new Sprite(data);\n    var sup = {\n      draw: that.superior('draw'),\n      cycle: that.superior('cycle'),\n      getSpeedX: that.superior('getSpeedX'),\n      getSpeedY: that.superior('getSpeedY'),\n      hits: that.superior('hits')\n    };\n    var directions = {\n      esEast: function esEast(xDiff) {\n        return xDiff > 300;\n      },\n      sEast: function sEast(xDiff) {\n        return xDiff > 75;\n      },\n      wsWest: function wsWest(xDiff) {\n        return xDiff < -300;\n      },\n      sWest: function sWest(xDiff) {\n        return xDiff < -75;\n      }\n    };\n    var cancelableStateTimeout;\n    var cancelableStateInterval;\n    var canSpeedBoost = true;\n    var obstaclesHit = [];\n    var pixelsTravelled = 0;\n    var standardSpeed = 5;\n    var boostMultiplier = 2;\n    var turnEaseCycles = 70;\n    var speedX = 0;\n    var speedXFactor = 0;\n    var speedY = 0;\n    var speedYFactor = 1;\n    var trickStep = 0; // There are three of these\n\n    that.isMoving = true;\n    that.hasBeenHit = false;\n    that.isJumping = false;\n    that.isPerformingTrick = false;\n\n    that.onHitObstacleCb = function () {};\n\n    that.setSpeed(standardSpeed);\n\n    that.reset = function () {\n      obstaclesHit = [];\n      pixelsTravelled = 0;\n      that.isMoving = true;\n      that.hasBeenHit = false;\n      canSpeedBoost = true;\n      setNormal();\n    };\n\n    function setNormal() {\n      that.setSpeed(standardSpeed);\n      that.isMoving = true;\n      that.hasBeenHit = false;\n      that.isJumping = false;\n      that.isPerformingTrick = false;\n\n      if (cancelableStateInterval) {\n        clearInterval(cancelableStateInterval);\n      }\n\n      that.setMapPosition(undefined, undefined, 0);\n    }\n\n    function setCrashed() {\n      that.isMoving = false;\n      that.hasBeenHit = true;\n      that.isJumping = false;\n      that.isPerformingTrick = false;\n\n      if (cancelableStateInterval) {\n        clearInterval(cancelableStateInterval);\n      }\n\n      that.setMapPosition(undefined, undefined, 0);\n    }\n\n    function setJumping() {\n      var currentSpeed = that.getSpeed();\n      that.setSpeed(currentSpeed + 2);\n      that.setSpeedY(currentSpeed + 2);\n      that.isMoving = true;\n      that.hasBeenHit = false;\n      that.isJumping = true;\n      that.setMapPosition(undefined, undefined, 1);\n    }\n\n    function getDiscreteDirection() {\n      if (that.direction) {\n        if (that.direction <= 90) {\n          return 'east';\n        } else if (that.direction > 90 && that.direction < 150) {\n          return 'esEast';\n        } else if (that.direction >= 150 && that.direction < 180) {\n          return 'sEast';\n        } else if (that.direction === 180) {\n          return 'south';\n        } else if (that.direction > 180 && that.direction <= 210) {\n          return 'sWest';\n        } else if (that.direction > 210 && that.direction < 270) {\n          return 'wsWest';\n        } else if (that.direction >= 270) {\n          return 'west';\n        } else {\n          return 'south';\n        }\n      } else {\n        var xDiff = that.movingToward[0] - that.mapPosition[0];\n        var yDiff = that.movingToward[1] - that.mapPosition[1];\n\n        if (yDiff <= 0) {\n          if (xDiff > 0) {\n            return 'east';\n          } else {\n            return 'west';\n          }\n        }\n\n        if (directions.esEast(xDiff)) {\n          return 'esEast';\n        } else if (directions.sEast(xDiff)) {\n          return 'sEast';\n        } else if (directions.wsWest(xDiff)) {\n          return 'wsWest';\n        } else if (directions.sWest(xDiff)) {\n          return 'sWest';\n        }\n      }\n\n      return 'south';\n    }\n\n    function setDiscreteDirection(d) {\n      if (discreteDirections[d]) {\n        that.setDirection(discreteDirections[d]);\n      }\n\n      if (d === 'west' || d === 'east') {\n        that.isMoving = false;\n      } else {\n        that.isMoving = true;\n      }\n    }\n\n    function getBeingEatenSprite() {\n      return 'blank';\n    }\n\n    function getJumpingSprite() {\n      return 'jumping';\n    }\n\n    function getTrickSprite() {\n      console.log('Trick step is', trickStep);\n\n      if (trickStep === 0) {\n        return 'jumping';\n      } else if (trickStep === 1) {\n        return 'somersault1';\n      } else {\n        return 'somersault2';\n      }\n    }\n\n    that.stop = function () {\n      if (that.direction > 180) {\n        setDiscreteDirection('west');\n      } else {\n        setDiscreteDirection('east');\n      }\n    };\n\n    that.turnEast = function () {\n      var discreteDirection = getDiscreteDirection();\n\n      switch (discreteDirection) {\n        case 'west':\n          setDiscreteDirection('wsWest');\n          break;\n\n        case 'wsWest':\n          setDiscreteDirection('sWest');\n          break;\n\n        case 'sWest':\n          setDiscreteDirection('south');\n          break;\n\n        case 'south':\n          setDiscreteDirection('sEast');\n          break;\n\n        case 'sEast':\n          setDiscreteDirection('esEast');\n          break;\n\n        case 'esEast':\n          setDiscreteDirection('east');\n          break;\n\n        default:\n          setDiscreteDirection('south');\n          break;\n      }\n    };\n\n    that.turnWest = function () {\n      var discreteDirection = getDiscreteDirection();\n\n      switch (discreteDirection) {\n        case 'east':\n          setDiscreteDirection('esEast');\n          break;\n\n        case 'esEast':\n          setDiscreteDirection('sEast');\n          break;\n\n        case 'sEast':\n          setDiscreteDirection('south');\n          break;\n\n        case 'south':\n          setDiscreteDirection('sWest');\n          break;\n\n        case 'sWest':\n          setDiscreteDirection('wsWest');\n          break;\n\n        case 'wsWest':\n          setDiscreteDirection('west');\n          break;\n\n        default:\n          setDiscreteDirection('south');\n          break;\n      }\n    };\n\n    that.stepWest = function () {\n      that.mapPosition[0] -= that.speed * 2;\n    };\n\n    that.stepEast = function () {\n      that.mapPosition[0] += that.speed * 2;\n    };\n\n    that.setMapPositionTarget = function (x, y) {\n      if (that.hasBeenHit) return;\n\n      if (Math.abs(that.mapPosition[0] - x) <= 75) {\n        x = that.mapPosition[0];\n      }\n\n      that.movingToward = [x, y]; // that.resetDirection();\n    };\n\n    that.startMovingIfPossible = function () {\n      if (!that.hasBeenHit && !that.isBeingEaten) {\n        that.isMoving = true;\n      }\n    };\n\n    that.setTurnEaseCycles = function (c) {\n      turnEaseCycles = c;\n    };\n\n    that.getPixelsTravelledDownMountain = function () {\n      return pixelsTravelled;\n    };\n\n    that.resetSpeed = function () {\n      that.setSpeed(standardSpeed);\n    };\n\n    that.cycle = function () {\n      if (that.getSpeedX() <= 0 && that.getSpeedY() <= 0) {\n        that.isMoving = false;\n      }\n\n      if (that.isMoving) {\n        pixelsTravelled += that.speed;\n      }\n\n      if (that.isJumping) {\n        that.setMapPositionTarget(undefined, that.mapPosition[1] + that.getSpeed());\n      }\n\n      sup.cycle();\n      that.checkHittableObjects();\n    };\n\n    that.draw = function (dContext) {\n      var spritePartToUse = function spritePartToUse() {\n        if (that.isBeingEaten) {\n          return getBeingEatenSprite();\n        }\n\n        if (that.isJumping) {\n          if (that.isPerformingTrick) {\n            return getTrickSprite();\n          }\n\n          return getJumpingSprite();\n        }\n\n        if (that.hasBeenHit) {\n          return 'hit';\n        }\n\n        return getDiscreteDirection();\n      };\n\n      return sup.draw(dContext, spritePartToUse());\n    };\n\n    that.hits = function (obs) {\n      if (obstaclesHit.indexOf(obs.id) !== -1) {\n        return false;\n      }\n\n      if (!obs.occupiesZIndex(that.mapPosition[2])) {\n        return false;\n      }\n\n      if (sup.hits(obs)) {\n        return true;\n      }\n\n      return false;\n    };\n\n    that.speedBoost = function () {\n      var originalSpeed = that.speed;\n\n      if (canSpeedBoost) {\n        canSpeedBoost = false;\n        that.setSpeed(that.speed * boostMultiplier);\n        setTimeout(function () {\n          that.setSpeed(originalSpeed);\n          setTimeout(function () {\n            canSpeedBoost = true;\n          }, 10000);\n        }, 2000);\n      }\n    };\n\n    that.attemptTrick = function () {\n      if (that.isJumping) {\n        that.isPerformingTrick = true;\n        cancelableStateInterval = setInterval(function () {\n          if (trickStep >= 2) {\n            trickStep = 0;\n          } else {\n            trickStep += 1;\n          }\n        }, 300);\n      }\n    };\n\n    that.getStandardSpeed = function () {\n      return standardSpeed;\n    };\n\n    function easeSpeedToTargetUsingFactor(sp, targetSpeed, f) {\n      if (f === 0 || f === 1) {\n        return targetSpeed;\n      }\n\n      if (sp < targetSpeed) {\n        sp += that.getSpeed() * (f / turnEaseCycles);\n      }\n\n      if (sp > targetSpeed) {\n        sp -= that.getSpeed() * (f / turnEaseCycles);\n      }\n\n      return sp;\n    }\n\n    that.getSpeedX = function () {\n      if (getDiscreteDirection() === 'esEast' || getDiscreteDirection() === 'wsWest') {\n        speedXFactor = 0.5;\n        speedX = easeSpeedToTargetUsingFactor(speedX, that.getSpeed() * speedXFactor, speedXFactor);\n        return speedX;\n      }\n\n      if (getDiscreteDirection() === 'sEast' || getDiscreteDirection() === 'sWest') {\n        speedXFactor = 0.33;\n        speedX = easeSpeedToTargetUsingFactor(speedX, that.getSpeed() * speedXFactor, speedXFactor);\n        return speedX;\n      } // So it must be south\n\n\n      speedX = easeSpeedToTargetUsingFactor(speedX, 0, speedXFactor);\n      return speedX;\n    };\n\n    that.setSpeedY = function (sy) {\n      speedY = sy;\n    };\n\n    that.getSpeedY = function () {\n      var targetSpeed;\n\n      if (that.isJumping) {\n        return speedY;\n      }\n\n      if (getDiscreteDirection() === 'esEast' || getDiscreteDirection() === 'wsWest') {\n        speedYFactor = 0.6;\n        speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed() * 0.6, 0.6);\n        return speedY;\n      }\n\n      if (getDiscreteDirection() === 'sEast' || getDiscreteDirection() === 'sWest') {\n        speedYFactor = 0.85;\n        speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed() * 0.85, 0.85);\n        return speedY;\n      }\n\n      if (getDiscreteDirection() === 'east' || getDiscreteDirection() === 'west') {\n        speedYFactor = 1;\n        speedY = 0;\n        return speedY;\n      } // So it must be south\n\n\n      speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed(), speedYFactor);\n      return speedY;\n    };\n\n    that.hasHitObstacle = function (obs) {\n      setCrashed();\n\n      if (navigator.vibrate) {\n        navigator.vibrate(500);\n      }\n\n      obstaclesHit.push(obs.id);\n      that.resetSpeed();\n      that.onHitObstacleCb(obs);\n\n      if (cancelableStateTimeout) {\n        clearTimeout(cancelableStateTimeout);\n      }\n\n      cancelableStateTimeout = setTimeout(function () {\n        setNormal();\n      }, 1500);\n    };\n\n    that.hasHitJump = function () {\n      setJumping();\n\n      if (cancelableStateTimeout) {\n        clearTimeout(cancelableStateTimeout);\n      }\n\n      cancelableStateTimeout = setTimeout(function () {\n        setNormal();\n      }, 1000);\n    };\n\n    that.isEatenBy = function (monster, whenEaten) {\n      that.hasHitObstacle(monster);\n      monster.startEating(whenEaten);\n      obstaclesHit.push(monster.id);\n      that.isMoving = false;\n      that.isBeingEaten = true;\n    };\n\n    that.reset = function () {\n      obstaclesHit = [];\n      pixelsTravelled = 0;\n      that.isMoving = true;\n      that.isJumping = false;\n      that.hasBeenHit = false;\n      canSpeedBoost = true;\n    };\n\n    that.setHitObstacleCb = function (fn) {\n      that.onHitObstacleCb = fn || function () {};\n    };\n\n    return that;\n  }\n\n  global.skier = Skier;\n})(this);\n\nif (true) {\n  module.exports = this.skier;\n}\n\n//# sourceURL=webpack:///./js/lib/skier.js?");

/***/ }),

/***/ "./js/lib/snowboarder.js":
/*!*******************************!*\
  !*** ./js/lib/snowboarder.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Sprite = __webpack_require__(/*! ./sprite */ \"./js/lib/sprite.js\");\n\n(function (global) {\n  function Snowboarder(data) {\n    var that = new Sprite(data);\n    var sup = {\n      draw: that.superior('draw'),\n      cycle: that.superior('cycle')\n    };\n    var directions = {\n      sEast: function sEast(xDiff) {\n        return xDiff > 0;\n      },\n      sWest: function sWest(xDiff) {\n        return xDiff <= 0;\n      }\n    };\n    var standardSpeed = 3;\n    that.setSpeed(standardSpeed);\n\n    function getDirection() {\n      var xDiff = that.movingToward[0] - that.mapPosition[0];\n      var yDiff = that.movingToward[1] - that.mapPosition[1];\n\n      if (directions.sEast(xDiff)) {\n        return 'sEast';\n      } else {\n        return 'sWest';\n      }\n    }\n\n    that.cycle = function (dContext) {\n      if (Number.random(10) === 1) {\n        that.setMapPositionTarget(dContext.getRandomlyInTheCentreOfMap());\n        that.setSpeed(standardSpeed + Number.random(-1, 1));\n      }\n\n      that.setMapPositionTarget(undefined, dContext.getMapBelowViewport() + 600);\n      sup.cycle();\n    };\n\n    that.draw = function (dContext) {\n      var spritePartToUse = function spritePartToUse() {\n        return getDirection();\n      };\n\n      return sup.draw(dContext, spritePartToUse());\n    };\n\n    return that;\n  }\n\n  global.snowboarder = Snowboarder;\n})(this);\n\nif (true) {\n  module.exports = this.snowboarder;\n}\n\n//# sourceURL=webpack:///./js/lib/snowboarder.js?");

/***/ }),

/***/ "./js/lib/sprite.js":
/*!**************************!*\
  !*** ./js/lib/sprite.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global) {\n  var GUID = __webpack_require__(/*! ./guid */ \"./js/lib/guid.js\");\n\n  function Sprite(data) {\n    var hittableObjects = {};\n    var zIndexesOccupied = [0];\n    var that = this;\n    var trackedSpriteToMoveToward;\n    that.direction = undefined;\n    that.mapPosition = [0, 0, 0];\n    that.id = GUID();\n    that.canvasX = 0;\n    that.canvasY = 0;\n    that.canvasZ = 0;\n    that.height = 0;\n    that.speed = 0;\n    that.data = data || {\n      parts: {}\n    };\n    that.movingToward = [0, 0];\n    that.metresDownTheMountain = 0;\n    that.movingWithConviction = false;\n    that.deleted = false;\n\n    that.maxHeight = function () {\n      return Object.values(that.data.parts).map(function (p) {\n        return p[3];\n      }).max();\n    }();\n\n    that.isMoving = true;\n\n    if (!that.data.parts) {\n      that.data.parts = {};\n    }\n\n    if (data && data.id) {\n      that.id = data.id;\n    }\n\n    if (data && data.zIndexesOccupied) {\n      zIndexesOccupied = data.zIndexesOccupied;\n    }\n\n    function incrementX(amount) {\n      that.canvasX += amount.toNumber();\n    }\n\n    function incrementY(amount) {\n      that.canvasY += amount.toNumber();\n    }\n\n    function getHitBox(forZIndex) {\n      if (that.data.hitBoxes) {\n        if (data.hitBoxes[forZIndex]) {\n          return data.hitBoxes[forZIndex];\n        }\n      }\n    }\n\n    function roundHalf(num) {\n      num = Math.round(num * 2) / 2;\n      return num;\n    }\n\n    function move() {\n      if (!that.isMoving) {\n        return;\n      }\n\n      var currentX = that.mapPosition[0];\n      var currentY = that.mapPosition[1];\n\n      if (typeof that.direction !== 'undefined') {\n        // For this we need to modify the that.direction so it relates to the horizontal\n        var d = that.direction - 90;\n        if (d < 0) d = 360 + d;\n        currentX += roundHalf(that.speed * Math.cos(d * (Math.PI / 180)));\n        currentY += roundHalf(that.speed * Math.sin(d * (Math.PI / 180)));\n      } else {\n        if (typeof that.movingToward[0] !== 'undefined') {\n          if (currentX > that.movingToward[0]) {\n            currentX -= Math.min(that.getSpeedX(), Math.abs(currentX - that.movingToward[0]));\n          } else if (currentX < that.movingToward[0]) {\n            currentX += Math.min(that.getSpeedX(), Math.abs(currentX - that.movingToward[0]));\n          }\n        }\n\n        if (typeof that.movingToward[1] !== 'undefined') {\n          if (currentY > that.movingToward[1]) {\n            currentY -= Math.min(that.getSpeedY(), Math.abs(currentY - that.movingToward[1]));\n          } else if (currentY < that.movingToward[1]) {\n            currentY += Math.min(that.getSpeedY(), Math.abs(currentY - that.movingToward[1]));\n          }\n        }\n      }\n\n      that.setMapPosition(currentX, currentY);\n    }\n\n    this.draw = function (dCtx, spriteFrame) {\n      var fr = that.data.parts[spriteFrame];\n      that.height = fr[3];\n      that.width = fr[2];\n      var newCanvasPosition = dCtx.mapPositionToCanvasPosition(that.mapPosition);\n      that.setCanvasPosition(newCanvasPosition[0], newCanvasPosition[1]);\n      dCtx.drawImage(dCtx.getLoadedImage(that.data.$imageFile), fr[0], fr[1], fr[2], fr[3], that.canvasX, that.canvasY, fr[2], fr[3]);\n    };\n\n    this.setMapPosition = function (x, y, z) {\n      if (typeof x === 'undefined') {\n        x = that.mapPosition[0];\n      }\n\n      if (typeof y === 'undefined') {\n        y = that.mapPosition[1];\n      }\n\n      if (typeof z === 'undefined') {\n        z = that.mapPosition[2];\n      } else {\n        that.zIndexesOccupied = [z];\n      }\n\n      that.mapPosition = [x, y, z];\n    };\n\n    this.setCanvasPosition = function (cx, cy) {\n      if (cx) {\n        if (Object.isString(cx) && (cx.first() === '+' || cx.first() === '-')) incrementX(cx);else that.canvasX = cx;\n      }\n\n      if (cy) {\n        if (Object.isString(cy) && (cy.first() === '+' || cy.first() === '-')) incrementY(cy);else that.canvasY = cy;\n      }\n    };\n\n    this.getCanvasPositionX = function () {\n      return that.canvasX;\n    };\n\n    this.getCanvasPositionY = function () {\n      return that.canvasY;\n    };\n\n    this.getLeftHitBoxEdge = function (zIndex) {\n      zIndex = zIndex || 0;\n      var lhbe = this.getCanvasPositionX();\n\n      if (getHitBox(zIndex)) {\n        lhbe += getHitBox(zIndex)[0];\n      }\n\n      return lhbe;\n    };\n\n    this.getTopHitBoxEdge = function (zIndex) {\n      zIndex = zIndex || 0;\n      var thbe = this.getCanvasPositionY();\n\n      if (getHitBox(zIndex)) {\n        thbe += getHitBox(zIndex)[1];\n      }\n\n      return thbe;\n    };\n\n    this.getRightHitBoxEdge = function (zIndex) {\n      zIndex = zIndex || 0;\n\n      if (getHitBox(zIndex)) {\n        return that.canvasX + getHitBox(zIndex)[2];\n      }\n\n      return that.canvasX + that.width;\n    };\n\n    this.getBottomHitBoxEdge = function (zIndex) {\n      zIndex = zIndex || 0;\n\n      if (getHitBox(zIndex)) {\n        return that.canvasY + getHitBox(zIndex)[3];\n      }\n\n      return that.canvasY + that.height;\n    };\n\n    this.getPositionInFrontOf = function () {\n      return [that.canvasX, that.canvasY + that.height];\n    };\n\n    this.setSpeed = function (s) {\n      that.speed = s;\n      that.speedX = s;\n      that.speedY = s;\n    };\n\n    this.incrementSpeedBy = function (s) {\n      that.speed += s;\n    };\n\n    that.getSpeed = function getSpeed() {\n      return that.speed;\n    };\n\n    that.getSpeedX = function () {\n      return that.speed;\n    };\n\n    that.getSpeedY = function () {\n      return that.speed;\n    };\n\n    this.setHeight = function (h) {\n      that.height = h;\n    };\n\n    this.setWidth = function (w) {\n      that.width = w;\n    };\n\n    this.getMaxHeight = function () {\n      return that.maxHeight;\n    };\n\n    that.getMovingTowardOpposite = function () {\n      if (!that.isMoving) {\n        return [0, 0];\n      }\n\n      var dx = that.movingToward[0] - that.mapPosition[0];\n      var dy = that.movingToward[1] - that.mapPosition[1];\n      var oppositeX = Math.abs(dx) > 75 ? 0 - dx : 0;\n      var oppositeY = -dy;\n      return [oppositeX, oppositeY];\n    };\n\n    this.checkHittableObjects = function () {\n      Object.keys(hittableObjects, function (k, objectData) {\n        if (objectData.object.deleted) {\n          delete hittableObjects[k];\n        } else {\n          if (objectData.object.hits(that)) {\n            objectData.callbacks.each(function (callback) {\n              callback(that, objectData.object);\n            });\n          }\n        }\n      });\n    };\n\n    this.cycle = function () {\n      that.checkHittableObjects();\n\n      if (trackedSpriteToMoveToward) {\n        that.setMapPositionTarget(trackedSpriteToMoveToward.mapPosition[0], trackedSpriteToMoveToward.mapPosition[1], true);\n      }\n\n      move();\n    };\n\n    this.setMapPositionTarget = function (x, y, override) {\n      if (override) {\n        that.movingWithConviction = false;\n      }\n\n      if (!that.movingWithConviction) {\n        if (typeof x === 'undefined') {\n          x = that.movingToward[0];\n        }\n\n        if (typeof y === 'undefined') {\n          y = that.movingToward[1];\n        }\n\n        that.movingToward = [x, y];\n        that.movingWithConviction = false;\n      } // that.resetDirection();\n\n    };\n\n    this.setDirection = function (angle) {\n      if (angle >= 360) {\n        angle = 360 - angle;\n      }\n\n      that.direction = angle;\n      that.movingToward = undefined;\n    };\n\n    this.resetDirection = function () {\n      that.direction = undefined;\n    };\n\n    this.setMapPositionTargetWithConviction = function (cx, cy) {\n      that.setMapPositionTarget(cx, cy);\n      that.movingWithConviction = true; // that.resetDirection();\n    };\n\n    this.follow = function (sprite) {\n      trackedSpriteToMoveToward = sprite; // that.resetDirection();\n    };\n\n    this.stopFollowing = function () {\n      trackedSpriteToMoveToward = false;\n    };\n\n    this.onHitting = function (objectToHit, callback) {\n      if (hittableObjects[objectToHit.id]) {\n        return hittableObjects[objectToHit.id].callbacks.push(callback);\n      }\n\n      hittableObjects[objectToHit.id] = {\n        object: objectToHit,\n        callbacks: [callback]\n      };\n    };\n\n    this.deleteOnNextCycle = function () {\n      that.deleted = true;\n    };\n\n    this.occupiesZIndex = function (z) {\n      return zIndexesOccupied.indexOf(z) >= 0;\n    };\n\n    this.hits = function (other) {\n      var verticalIntersect = false;\n      var horizontalIntersect = false; // Test that THIS has a bottom edge inside of the other object\n\n      if (other.getTopHitBoxEdge(that.mapPosition[2]) <= that.getBottomHitBoxEdge(that.mapPosition[2]) && other.getBottomHitBoxEdge(that.mapPosition[2]) >= that.getBottomHitBoxEdge(that.mapPosition[2])) {\n        verticalIntersect = true;\n      } // Test that THIS has a top edge inside of the other object\n\n\n      if (other.getTopHitBoxEdge(that.mapPosition[2]) <= that.getTopHitBoxEdge(that.mapPosition[2]) && other.getBottomHitBoxEdge(that.mapPosition[2]) >= that.getTopHitBoxEdge(that.mapPosition[2])) {\n        verticalIntersect = true;\n      } // Test that THIS has a right edge inside of the other object\n\n\n      if (other.getLeftHitBoxEdge(that.mapPosition[2]) <= that.getRightHitBoxEdge(that.mapPosition[2]) && other.getRightHitBoxEdge(that.mapPosition[2]) >= that.getRightHitBoxEdge(that.mapPosition[2])) {\n        horizontalIntersect = true;\n      } // Test that THIS has a left edge inside of the other object\n\n\n      if (other.getLeftHitBoxEdge(that.mapPosition[2]) <= that.getLeftHitBoxEdge(that.mapPosition[2]) && other.getRightHitBoxEdge(that.mapPosition[2]) >= that.getLeftHitBoxEdge(that.mapPosition[2])) {\n        horizontalIntersect = true;\n      }\n\n      return verticalIntersect && horizontalIntersect;\n    };\n\n    this.isAboveOnCanvas = function (cy) {\n      return that.canvasY + that.height < cy;\n    };\n\n    this.isBelowOnCanvas = function (cy) {\n      return that.canvasY > cy;\n    };\n\n    return that;\n  }\n\n  Sprite.createObjects = function createObjects(spriteInfoArray, opts) {\n    if (!Array.isArray(spriteInfoArray)) spriteInfoArray = [spriteInfoArray];\n    opts = Object.merge(opts, {\n      rateModifier: 0,\n      dropRate: 1,\n      position: [0, 0]\n    }, false, false);\n\n    function createOne(spriteInfo) {\n      var position = opts.position;\n\n      if (Number.random(100 + opts.rateModifier) <= spriteInfo.dropRate) {\n        var sprite = new Sprite(spriteInfo.sprite);\n        sprite.setSpeed(0);\n\n        if (Object.isFunction(position)) {\n          position = position();\n        }\n\n        sprite.setMapPosition(position[0], position[1]);\n\n        if (spriteInfo.sprite.hitBehaviour && spriteInfo.sprite.hitBehaviour.skier && opts.player) {\n          sprite.onHitting(opts.player, spriteInfo.sprite.hitBehaviour.skier);\n        }\n\n        return sprite;\n      }\n    }\n\n    var objects = spriteInfoArray.map(createOne).remove(undefined);\n    return objects;\n  };\n\n  global.sprite = Sprite;\n})(this);\n\nif (true) {\n  module.exports = this.sprite;\n}\n\n//# sourceURL=webpack:///./js/lib/sprite.js?");

/***/ }),

/***/ "./js/lib/spriteArray.js":
/*!*******************************!*\
  !*** ./js/lib/spriteArray.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar SpriteArray =\n/*#__PURE__*/\nfunction (_Array) {\n  _inherits(SpriteArray, _Array);\n\n  function SpriteArray() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, SpriteArray);\n\n    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n      items[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteArray)).call.apply(_getPrototypeOf2, [this].concat(items)));\n    _this.pushHandlers = [];\n    return _this;\n  }\n\n  _createClass(SpriteArray, [{\n    key: \"onPush\",\n    value: function onPush(f, retroactive) {\n      this.pushHandlers.push(f);\n\n      if (retroactive) {\n        this.each(f);\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(obj) {\n      Array.prototype.push.call(this, obj);\n      this.pushHandlers.each(function (handler) {\n        handler(obj);\n      });\n    }\n  }, {\n    key: \"cull\",\n    value: function cull() {\n      this.each(function (obj, i) {\n        if (obj.deleted) {\n          return delete this[i];\n        }\n      });\n    }\n  }]);\n\n  return SpriteArray;\n}(_wrapNativeSuper(Array));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SpriteArray); // (function (global) {\n// \tfunction SpriteArray() {\n// \t\tthis.pushHandlers = [];\n// \t\treturn this;\n// \t}\n// \tSpriteArray.prototype = Object.create(Array.prototype);\n// \tSpriteArray.prototype.onPush = function(f, retroactive) {\n// \t\tthis.pushHandlers.push(f);\n// \t\tif (retroactive) {\n// \t\t\tthis.each(f);\n// \t\t}\n// \t};\n// \tSpriteArray.prototype.push = function(obj) {\n// \t\tArray.prototype.push.call(this, obj);\n// \t\tthis.pushHandlers.each(function(handler) {\n// \t\t\thandler(obj);\n// \t\t});\n// \t};\n// \tSpriteArray.prototype.cull = function() {\n// \t\tthis.each(function (obj, i) {\n// \t\t\tif (obj.deleted) {\n// \t\t\t\treturn (delete this[i]);\n// \t\t\t}\n// \t\t});\n// \t};\n// \tglobal.spriteArray = SpriteArray;\n// })(this);\n// if (typeof module !== 'undefined') {\n// \tmodule.exports = this.spriteArray;\n// }\n\n//# sourceURL=webpack:///./js/lib/spriteArray.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_canvasRenderingContext2DExtensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/canvasRenderingContext2DExtensions */ \"./js/lib/canvasRenderingContext2DExtensions.js\");\n/* harmony import */ var _lib_canvasRenderingContext2DExtensions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_canvasRenderingContext2DExtensions__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_extenders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/extenders */ \"./js/lib/extenders.js\");\n/* harmony import */ var _lib_extenders__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lib_extenders__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_plugins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/plugins */ \"./js/lib/plugins.js\");\n/* harmony import */ var _lib_plugins__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_plugins__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hammerjs */ \"./node_modules/hammerjs/hammer.js\");\n/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var br_mousetrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! br-mousetrap */ \"./node_modules/br-mousetrap/mousetrap.js\");\n/* harmony import */ var br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(br_mousetrap__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lib_isMobileDevice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/isMobileDevice */ \"./js/lib/isMobileDevice.js\");\n/* harmony import */ var _lib_isMobileDevice__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lib_isMobileDevice__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lib_monster__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/monster */ \"./js/lib/monster.js\");\n/* harmony import */ var _lib_monster__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lib_monster__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lib_sprite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/sprite */ \"./js/lib/sprite.js\");\n/* harmony import */ var _lib_sprite__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lib_sprite__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _lib_snowboarder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/snowboarder */ \"./js/lib/snowboarder.js\");\n/* harmony import */ var _lib_snowboarder__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lib_snowboarder__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lib_skier__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/skier */ \"./js/lib/skier.js\");\n/* harmony import */ var _lib_skier__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lib_skier__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lib_infoBox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/infoBox */ \"./js/lib/infoBox.js\");\n/* harmony import */ var _lib_infoBox__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lib_infoBox__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lib_game__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/game */ \"./js/lib/game.js\");\n/* harmony import */ var _spriteInfo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./spriteInfo */ \"./js/spriteInfo.js\");\n/* harmony import */ var _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_spriteInfo__WEBPACK_IMPORTED_MODULE_12__);\n// Global dependencies which return no modules\n\n\n // External dependencies\n\n\n // Method modules\n\n // Game Objects\n\n\n\n\n\n\n // Local variables for starting the game\n\nvar mainCanvas = document.getElementById('skifree-canvas');\nvar dContext = mainCanvas.getContext('2d');\nvar imageSources = ['sprite-characters.png', 'skifree-objects.png'];\nvar infoBoxControls = 'Use the mouse or WASD to control the player';\nif (_lib_isMobileDevice__WEBPACK_IMPORTED_MODULE_5___default()()) infoBoxControls = 'Tap or drag on the piste to control the player';\n\nvar pixelsPerMetre = 18;\nvar distanceTravelledInMetres = 0;\nvar monsterDistanceThreshold = 2000;\nvar livesLeft = 5;\nvar highScore = 0;\nvar loseLifeOnObstacleHit = false;\nvar dropRates = {\n  smallTree: 4,\n  tallTree: 2,\n  jump: 1,\n  thickSnow: 1,\n  rock: 1\n};\nif (localStorage.getItem('highScore')) highScore = localStorage.getItem('highScore');\n\nfunction loadImages(sources, next) {\n  var loaded = 0;\n  var images = {};\n\n  function finish() {\n    loaded += 1;\n\n    if (loaded === sources.length) {\n      next(images);\n    }\n  }\n\n  sources.each(function (src) {\n    var im = new Image();\n    im.onload = finish;\n    im.src = src;\n    dContext.storeLoadedImage(src, im);\n  });\n}\n\nfunction monsterHitsSkierBehaviour(monster, skier) {\n  skier.isEatenBy(monster, function () {\n    livesLeft -= 1;\n    monster.isFull = true;\n    monster.isEating = false;\n    skier.isBeingEaten = false;\n    monster.setSpeed(skier.getSpeed());\n    monster.stopFollowing();\n    var randomPositionAbove = dContext.getRandomMapPositionAboveViewport();\n    monster.setMapPositionTarget(randomPositionAbove[0], randomPositionAbove[1]);\n  });\n}\n\nfunction startNeverEndingGame(images) {\n  var player;\n  var startSign;\n  var infoBox;\n  var game;\n\n  function resetGame() {\n    distanceTravelledInMetres = 0;\n    livesLeft = 5;\n    highScore = localStorage.getItem('highScore');\n    game.reset();\n    game.addStaticObject(startSign);\n  }\n\n  function detectEnd() {\n    if (!game.isPaused()) {\n      highScore = localStorage.setItem('highScore', distanceTravelledInMetres);\n      infoBox.setLines(['Game over!', 'Hit space to restart']);\n      game.pause();\n      game.cycle();\n    }\n  }\n\n  function randomlySpawnNPC(spawnFunction, dropRate) {\n    var rateModifier = Math.max(800 - mainCanvas.width, 0);\n\n    if (Number.random(1000 + rateModifier) <= dropRate) {\n      spawnFunction();\n    }\n  }\n\n  function spawnMonster() {\n    var newMonster = new _lib_monster__WEBPACK_IMPORTED_MODULE_6___default.a(_spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.monster);\n    var randomPosition = dContext.getRandomMapPositionAboveViewport();\n    newMonster.setMapPosition(randomPosition[0], randomPosition[1]);\n    newMonster.follow(player);\n    newMonster.setSpeed(player.getStandardSpeed());\n    newMonster.onHitting(player, monsterHitsSkierBehaviour);\n    game.addMovingObject(newMonster, 'monster');\n  }\n\n  function spawnBoarder() {\n    var newBoarder = new _lib_snowboarder__WEBPACK_IMPORTED_MODULE_8___default.a(_spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.snowboarder);\n    var randomPositionAbove = dContext.getRandomMapPositionAboveViewport();\n    var randomPositionBelow = dContext.getRandomMapPositionBelowViewport();\n    newBoarder.setMapPosition(randomPositionAbove[0], randomPositionAbove[1]);\n    newBoarder.setMapPositionTarget(randomPositionBelow[0], randomPositionBelow[1]);\n    newBoarder.onHitting(player, _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.snowboarder.hitBehaviour.skier);\n    game.addMovingObject(newBoarder);\n  }\n\n  player = new _lib_skier__WEBPACK_IMPORTED_MODULE_9___default.a(_spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.skier);\n  player.setMapPosition(0, 0);\n  player.setMapPositionTarget(0, -10);\n\n  if (loseLifeOnObstacleHit) {\n    player.setHitObstacleCb(function () {\n      livesLeft -= 1;\n    });\n  }\n\n  game = new _lib_game__WEBPACK_IMPORTED_MODULE_11__[\"default\"](mainCanvas, player);\n  startSign = new _lib_sprite__WEBPACK_IMPORTED_MODULE_7___default.a(_spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.signStart);\n  game.addStaticObject(startSign);\n  startSign.setMapPosition(-50, 0);\n  dContext.followSprite(player);\n  infoBox = new _lib_infoBox__WEBPACK_IMPORTED_MODULE_10___default.a({\n    initialLines: ['SkiFree.js', infoBoxControls, 'Travelled 0m', 'High Score: ' + highScore, 'Skiers left: ' + livesLeft, 'Created by Dan Hough (@basicallydan)'],\n    position: {\n      top: 15,\n      right: 10\n    }\n  });\n  game.beforeCycle(function () {\n    var newObjects = [];\n\n    if (player.isMoving) {\n      newObjects = _lib_sprite__WEBPACK_IMPORTED_MODULE_7___default.a.createObjects([{\n        sprite: _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.smallTree,\n        dropRate: dropRates.smallTree\n      }, {\n        sprite: _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.tallTree,\n        dropRate: dropRates.tallTree\n      }, {\n        sprite: _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.jump,\n        dropRate: dropRates.jump\n      }, {\n        sprite: _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.thickSnow,\n        dropRate: dropRates.thickSnow\n      }, {\n        sprite: _spriteInfo__WEBPACK_IMPORTED_MODULE_12___default.a.rock,\n        dropRate: dropRates.rock\n      }], {\n        rateModifier: Math.max(800 - mainCanvas.width, 0),\n        position: function position() {\n          return dContext.getRandomMapPositionBelowViewport();\n        },\n        player: player\n      });\n    }\n\n    if (!game.isPaused()) {\n      game.addStaticObjects(newObjects);\n      randomlySpawnNPC(spawnBoarder, 0.1);\n      distanceTravelledInMetres = parseFloat(player.getPixelsTravelledDownMountain() / pixelsPerMetre).toFixed(1);\n\n      if (distanceTravelledInMetres > monsterDistanceThreshold) {\n        randomlySpawnNPC(spawnMonster, 0.001);\n      }\n\n      infoBox.setLines(['SkiFree.js', infoBoxControls, 'Travelled ' + distanceTravelledInMetres + 'm', 'Skiers left: ' + livesLeft, 'High Score: ' + highScore, 'Created by Dan Hough (@basicallydan)', 'Current Speed: ' + player.getSpeed()\n      /*,\n      'Skier Map Position: ' + player.mapPosition[0].toFixed(1) + ', ' + player.mapPosition[1].toFixed(1),\n      'Mouse Map Position: ' + mouseMapPosition[0].toFixed(1) + ', ' + mouseMapPosition[1].toFixed(1)*/\n      ]);\n    }\n  });\n  game.afterCycle(function () {\n    if (livesLeft === 0) {\n      detectEnd();\n    }\n  });\n  game.addUIElement(infoBox);\n  $(mainCanvas).mousemove(function (e) {\n    game.setMouseX(e.pageX);\n    game.setMouseY(e.pageY);\n    player.resetDirection();\n    player.startMovingIfPossible();\n  }).bind('click', function (e) {\n    game.setMouseX(e.pageX);\n    game.setMouseY(e.pageY);\n    player.resetDirection();\n    player.startMovingIfPossible();\n  }).focus(); // So we can listen to events immediately\n\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind('f', player.speedBoost);\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind('t', player.attemptTrick);\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind(['w', 'up'], function () {\n    player.stop();\n  });\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind(['a', 'left'], function () {\n    if (player.direction === 270) {\n      player.stepWest();\n    } else {\n      player.turnWest();\n    }\n  });\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind(['s', 'down'], function () {\n    player.setDirection(180);\n    player.startMovingIfPossible();\n  });\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind(['d', 'right'], function () {\n    if (player.direction === 90) {\n      player.stepEast();\n    } else {\n      player.turnEast();\n    }\n  });\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind('m', spawnMonster);\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind('b', spawnBoarder);\n  br_mousetrap__WEBPACK_IMPORTED_MODULE_4___default.a.bind('space', resetGame);\n  var hammertime = new hammerjs__WEBPACK_IMPORTED_MODULE_3___default.a(mainCanvas);\n  hammertime.on('press', function (e) {\n    e.preventDefault();\n    game.setMouseX(e.gesture.center.x);\n    game.setMouseY(e.gesture.center.y);\n  });\n  hammertime.on('tap', function (e) {\n    game.setMouseX(e.gesture.center.x);\n    game.setMouseY(e.gesture.center.y);\n  });\n  hammertime.on('pan', function (e) {\n    game.setMouseX(e.gesture.center.x);\n    game.setMouseY(e.gesture.center.y);\n    player.resetDirection();\n    player.startMovingIfPossible();\n  });\n  hammertime.on('doubletap', function (e) {\n    player.speedBoost();\n  });\n  player.isMoving = false;\n  player.setDirection(270);\n  game.start();\n}\n\nfunction resizeCanvas() {\n  mainCanvas.width = window.innerWidth;\n  mainCanvas.height = window.innerHeight;\n}\n\nwindow.addEventListener('resize', resizeCanvas, false);\nresizeCanvas();\nloadImages(imageSources, startNeverEndingGame);\n\n//# sourceURL=webpack:///./js/main.js?");

/***/ }),

/***/ "./js/spriteInfo.js":
/*!**************************!*\
  !*** ./js/spriteInfo.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global) {\n  var sprites = {\n    'skier': {\n      $imageFile: 'sprite-characters.png',\n      parts: {\n        blank: [0, 0, 0, 0],\n        east: [0, 0, 24, 34],\n        esEast: [24, 0, 24, 34],\n        sEast: [49, 0, 17, 34],\n        south: [65, 0, 17, 34],\n        sWest: [49, 37, 17, 34],\n        wsWest: [24, 37, 24, 34],\n        west: [0, 37, 24, 34],\n        hit: [0, 78, 31, 31],\n        jumping: [84, 0, 32, 34],\n        somersault1: [116, 0, 32, 34],\n        somersault2: [148, 0, 32, 34]\n      },\n      hitBoxes: {\n        0: [7, 20, 27, 34]\n      },\n      id: 'player',\n      hitBehaviour: {}\n    },\n    'smallTree': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [0, 28, 30, 34]\n      },\n      hitBoxes: {\n        0: [0, 18, 30, 34]\n      },\n      hitBehaviour: {}\n    },\n    'tallTree': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [95, 66, 32, 64]\n      },\n      zIndexesOccupied: [0, 1],\n      hitBoxes: {\n        0: [0, 54, 32, 64],\n        1: [0, 10, 32, 54]\n      },\n      hitBehaviour: {}\n    },\n    'thickSnow': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [143, 53, 43, 10]\n      },\n      hitBehaviour: {}\n    },\n    'rock': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [30, 52, 23, 11]\n      },\n      hitBehaviour: {}\n    },\n    'monster': {\n      $imageFile: 'sprite-characters.png',\n      parts: {\n        sEast1: [64, 112, 26, 43],\n        sEast2: [90, 112, 32, 43],\n        sWest1: [64, 158, 26, 43],\n        sWest2: [90, 158, 32, 43],\n        eating1: [122, 112, 34, 43],\n        eating2: [156, 112, 31, 43],\n        eating3: [187, 112, 31, 43],\n        eating4: [219, 112, 25, 43],\n        eating5: [243, 112, 26, 43]\n      },\n      hitBehaviour: {}\n    },\n    'jump': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [109, 55, 32, 8]\n      },\n      hitBehaviour: {}\n    },\n    'signStart': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [260, 103, 42, 27]\n      },\n      hitBehaviour: {}\n    },\n    'snowboarder': {\n      $imageFile: 'sprite-characters.png',\n      parts: {\n        sEast: [73, 229, 20, 29],\n        sWest: [95, 228, 26, 30]\n      },\n      hitBehaviour: {}\n    },\n    'emptyChairLift': {\n      $imageFile: 'skifree-objects.png',\n      parts: {\n        main: [92, 136, 26, 30]\n      },\n      zIndexesOccupied: [1]\n    }\n  };\n\n  function monsterHitsTreeBehaviour(monster) {\n    monster.deleteOnNextCycle();\n  }\n\n  sprites.monster.hitBehaviour.tree = monsterHitsTreeBehaviour;\n\n  function treeHitsMonsterBehaviour(tree, monster) {\n    monster.deleteOnNextCycle();\n  }\n\n  sprites.smallTree.hitBehaviour.monster = treeHitsMonsterBehaviour;\n  sprites.tallTree.hitBehaviour.monster = treeHitsMonsterBehaviour;\n\n  function skierHitsTreeBehaviour(skier, tree) {\n    skier.hasHitObstacle(tree);\n  }\n\n  function treeHitsSkierBehaviour(tree, skier) {\n    skier.hasHitObstacle(tree);\n  }\n\n  sprites.smallTree.hitBehaviour.skier = treeHitsSkierBehaviour;\n  sprites.tallTree.hitBehaviour.skier = treeHitsSkierBehaviour;\n\n  function rockHitsSkierBehaviour(rock, skier) {\n    skier.hasHitObstacle(rock);\n  }\n\n  sprites.rock.hitBehaviour.skier = rockHitsSkierBehaviour;\n\n  function skierHitsJumpBehaviour(skier, jump) {\n    skier.hasHitJump(jump);\n  }\n\n  function jumpHitsSkierBehaviour(jump, skier) {\n    skier.hasHitJump(jump);\n  }\n\n  sprites.jump.hitBehaviour.skier = jumpHitsSkierBehaviour; // Really not a fan of this behaviour.\n\n  /*\tfunction skierHitsThickSnowBehaviour(skier, thickSnow) {\n  \t\t// Need to implement this properly\n  \t\tskier.setSpeed(2);\n  \t\tsetTimeout(function() {\n  \t\t\tskier.resetSpeed();\n  \t\t}, 700);\n  \t}\n  \n  \tfunction thickSnowHitsSkierBehaviour(thickSnow, skier) {\n  \t\t// Need to implement this properly\n  \t\tskier.setSpeed(2);\n  \t\tsetTimeout(function() {\n  \t\t\tskier.resetSpeed();\n  \t\t}, 300);\n  \t}*/\n  // sprites.thickSnow.hitBehaviour.skier = thickSnowHitsSkierBehaviour;\n\n  function snowboarderHitsSkierBehaviour(snowboarder, skier) {\n    skier.hasHitObstacle(snowboarder);\n  }\n\n  sprites.snowboarder.hitBehaviour.skier = snowboarderHitsSkierBehaviour;\n  global.spriteInfo = sprites;\n})(this);\n\nif (true) {\n  module.exports = this.spriteInfo;\n}\n\n//# sourceURL=webpack:///./js/spriteInfo.js?");

/***/ }),

/***/ "./node_modules/br-mousetrap/mousetrap.js":
/*!************************************************!*\
  !*** ./node_modules/br-mousetrap/mousetrap.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Copyright 2012 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.1.3\n * @url craig.is/killing/mice\n */\n(function() {\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n            8: 'backspace',\n            9: 'tab',\n            13: 'enter',\n            16: 'shift',\n            17: 'ctrl',\n            18: 'alt',\n            20: 'capslock',\n            27: 'esc',\n            32: 'space',\n            33: 'pageup',\n            34: 'pagedown',\n            35: 'end',\n            36: 'home',\n            37: 'left',\n            38: 'up',\n            39: 'right',\n            40: 'down',\n            45: 'ins',\n            46: 'del',\n            91: 'meta',\n            93: 'meta',\n            224: 'meta'\n        },\n\n        /**\n         * mapping for special characters so they can support\n         *\n         * this dictionary is only used incase you want to bind a\n         * keyup or keydown event to one of these keys\n         *\n         * @type {Object}\n         */\n        _KEYCODE_MAP = {\n            106: '*',\n            107: '+',\n            109: '-',\n            110: '.',\n            111 : '/',\n            186: ';',\n            187: '=',\n            188: ',',\n            189: '-',\n            190: '.',\n            191: '/',\n            192: '`',\n            219: '[',\n            220: '\\\\',\n            221: ']',\n            222: '\\''\n        },\n\n        /**\n         * this is a mapping of keys that require shift on a US keypad\n         * back to the non shift equivelents\n         *\n         * this is so you can use keyup events with these keys\n         *\n         * note that this will only work reliably on US keyboards\n         *\n         * @type {Object}\n         */\n        _SHIFT_MAP = {\n            '~': '`',\n            '!': '1',\n            '@': '2',\n            '#': '3',\n            '$': '4',\n            '%': '5',\n            '^': '6',\n            '&': '7',\n            '*': '8',\n            '(': '9',\n            ')': '0',\n            '_': '-',\n            '+': '=',\n            ':': ';',\n            '\\\"': '\\'',\n            '<': ',',\n            '>': '.',\n            '?': '/',\n            '|': '\\\\'\n        },\n\n        /**\n         * this is a list of special strings you can use to map\n         * to modifier keys when you specify your keyboard shortcuts\n         *\n         * @type {Object}\n         */\n        _SPECIAL_ALIASES = {\n            'option': 'alt',\n            'command': 'meta',\n            'return': 'enter',\n            'escape': 'esc'\n        },\n\n        /**\n         * variable to store the flipped version of _MAP from above\n         * needed to check if we should use keypress or not when no action\n         * is specified\n         *\n         * @type {Object|undefined}\n         */\n        _REVERSE_MAP,\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        _callbacks = {},\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        _direct_map = {},\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        _sequence_levels = {},\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        _reset_timer,\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        _ignore_next_keyup = false,\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        _inside_sequence = false;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n        _MAP[i + 96] = i;\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            return String.fromCharCode(e.which);\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} do_not_reset\n     * @returns void\n     */\n    function _resetSequences(do_not_reset) {\n        do_not_reset = do_not_reset || {};\n\n        var active_sequences = false,\n            key;\n\n        for (key in _sequence_levels) {\n            if (do_not_reset[key]) {\n                active_sequences = true;\n                continue;\n            }\n            _sequence_levels[key] = 0;\n        }\n\n        if (!active_sequences) {\n            _inside_sequence = false;\n        }\n    }\n\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {boolean=} remove - should we remove any matches\n     * @param {string=} combination\n     * @returns {Array}\n     */\n    function _getMatches(character, modifiers, e, remove, combination) {\n        var i,\n            callback,\n            matches = [],\n            action = e.type;\n\n        // if there are no events related to this keycode\n        if (!_callbacks[character]) {\n            return [];\n        }\n\n        // if a modifier key is coming up on its own we should allow it\n        if (action == 'keyup' && _isModifier(character)) {\n            modifiers = [character];\n        }\n\n        // loop through all callbacks for the key that was pressed\n        // and see if any of them match\n        for (i = 0; i < _callbacks[character].length; ++i) {\n            callback = _callbacks[character][i];\n\n            // if this is a sequence but it is not at the right level\n            // then move onto the next match\n            if (callback.seq && _sequence_levels[callback.seq] != callback.level) {\n                continue;\n            }\n\n            // if the action we are looking for doesn't match the action we got\n            // then we should keep going\n            if (action != callback.action) {\n                continue;\n            }\n\n            // if this is a keypress event and the meta key and control key\n            // are not pressed that means that we need to only look at the\n            // character, otherwise check the modifiers as well\n            //\n            // chrome will not fire a keypress if meta or control is down\n            // safari will fire a keypress if meta or meta+shift is down\n            // firefox will fire a keypress if meta or control is down\n            if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                // remove is used so if you change your mind and call bind a\n                // second time with a new function the first one is overwritten\n                if (remove && callback.combo == combination) {\n                    _callbacks[character].splice(i, 1);\n                }\n\n                matches.push(callback);\n            }\n        }\n\n        return matches;\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n    function _fireCallback(callback, e) {\n        if (callback(e) === false) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n\n            if (e.stopPropagation) {\n                e.stopPropagation();\n            }\n\n            e.returnValue = false;\n            e.cancelBubble = true;\n        }\n    }\n\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Event} e\n     * @returns void\n     */\n    function _handleCharacter(character, e) {\n\n        // if this event should not happen stop here\n        if (Mousetrap.stopCallback(e, e.target || e.srcElement)) {\n            return;\n        }\n\n        var callbacks = _getMatches(character, _eventModifiers(e), e),\n            i,\n            do_not_reset = {},\n            processed_sequence_callback = false;\n\n        // loop through matching callbacks for this key event\n        for (i = 0; i < callbacks.length; ++i) {\n\n            // fire for all sequence callbacks\n            // this is because if for example you have multiple sequences\n            // bound such as \"g i\" and \"g t\" they both need to fire the\n            // callback for matching g cause otherwise you can only ever\n            // match the first one\n            if (callbacks[i].seq) {\n                processed_sequence_callback = true;\n\n                // keep a list of which sequences were matches for later\n                do_not_reset[callbacks[i].seq] = 1;\n                _fireCallback(callbacks[i].callback, e);\n                continue;\n            }\n\n            // if there were no sequence matches but we are still here\n            // that means this is a regular match so we should fire that\n            if (!processed_sequence_callback && !_inside_sequence) {\n                _fireCallback(callbacks[i].callback, e);\n            }\n        }\n\n        // if you are inside of a sequence and the key you are pressing\n        // is not a modifier key then we should reset all sequences\n        // that were not matched by this key event\n        if (e.type == _inside_sequence && !_isModifier(character)) {\n            _resetSequences(do_not_reset);\n        }\n    }\n\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _handleKey(e) {\n\n        // normalize e.which for key events\n        // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n        e.which = typeof e.which == \"number\" ? e.which : e.keyCode;\n\n        var character = _characterFromEvent(e);\n\n        // no character found then stop\n        if (!character) {\n            return;\n        }\n\n        if (e.type == 'keyup' && _ignore_next_keyup == character) {\n            _ignore_next_keyup = false;\n            return;\n        }\n\n        _handleCharacter(character, e);\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n    function _resetSequenceTimer() {\n        clearTimeout(_reset_timer);\n        _reset_timer = setTimeout(_resetSequences, 1000);\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n    function _bindSequence(combo, keys, callback, action) {\n\n        // start off by adding a sequence level record for this combination\n        // and setting the level to 0\n        _sequence_levels[combo] = 0;\n\n        // if there is no action pick the best one for the first key\n        // in the sequence\n        if (!action) {\n            action = _pickBestAction(keys[0], []);\n        }\n\n        /**\n         * callback to increase the sequence level for this sequence and reset\n         * all other sequences that were active\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        var _increaseSequence = function(e) {\n                _inside_sequence = action;\n                ++_sequence_levels[combo];\n                _resetSequenceTimer();\n            },\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            _callbackAndReset = function(e) {\n                _fireCallback(callback, e);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignore_next_keyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            },\n            i;\n\n        // loop through keys one at a time and bind the appropriate callback\n        // function.  for any key leading up to the final one it should\n        // increase the sequence. after the final, it should reset all sequences\n        for (i = 0; i < keys.length; ++i) {\n            _bindSingle(keys[i], i < keys.length - 1 ? _increaseSequence : _callbackAndReset, action, combo, i);\n        }\n    }\n\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequence_name - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n    function _bindSingle(combination, callback, action, sequence_name, level) {\n\n        // make sure multiple spaces in a row become a single space\n        combination = combination.replace(/\\s+/g, ' ');\n\n        var sequence = combination.split(' '),\n            i,\n            key,\n            keys,\n            modifiers = [];\n\n        // if this pattern is a sequence of keys then run through this method\n        // to reprocess each pattern one key at a time\n        if (sequence.length > 1) {\n            _bindSequence(combination, sequence, callback, action);\n            return;\n        }\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = combination === '+' ? ['+'] : combination.split('+');\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        // make sure to initialize array if this is the first time\n        // a callback is added for this key\n        if (!_callbacks[key]) {\n            _callbacks[key] = [];\n        }\n\n        // remove an existing match if there is one\n        _getMatches(key, modifiers, {type: action}, !sequence_name, combination);\n\n        // add this call back to the array\n        // if it is a sequence put it at the beginning\n        // if not put it at the end\n        //\n        // this is important because the way these are processed expects\n        // the sequence ones to come first\n        _callbacks[key][sequence_name ? 'unshift' : 'push']({\n            callback: callback,\n            modifiers: modifiers,\n            action: action,\n            seq: sequence_name,\n            level: level,\n            combo: combination\n        });\n    }\n\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n    function _bindMultiple(combinations, callback, action) {\n        for (var i = 0; i < combinations.length; ++i) {\n            _bindSingle(combinations[i], callback, action);\n        }\n    }\n\n    // start!\n    _addEvent(document, 'keypress', _handleKey);\n    _addEvent(document, 'keydown', _handleKey);\n    _addEvent(document, 'keyup', _handleKey);\n\n    var Mousetrap = {\n\n        /**\n         * binds an event to mousetrap\n         *\n         * can be a single key, a combination of keys separated with +,\n         * an array of keys, or a sequence of keys separated by spaces\n         *\n         * be sure to list the modifier keys first to make sure that the\n         * correct key ends up getting bound (the last key in the pattern)\n         *\n         * @param {string|Array} keys\n         * @param {Function} callback\n         * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n         * @returns void\n         */\n        bind: function(keys, callback, action) {\n            _bindMultiple(keys instanceof Array ? keys : [keys], callback, action);\n            _direct_map[keys + ':' + action] = callback;\n            return this;\n        },\n\n        /**\n         * unbinds an event to mousetrap\n         *\n         * the unbinding sets the callback function of the specified key combo\n         * to an empty function and deletes the corresponding key in the\n         * _direct_map dict.\n         *\n         * the keycombo+action has to be exactly the same as\n         * it was defined in the bind method\n         *\n         * TODO: actually remove this from the _callbacks dictionary instead\n         * of binding an empty function\n         *\n         * @param {string|Array} keys\n         * @param {string} action\n         * @returns void\n         */\n        unbind: function(keys, action) {\n            if (_direct_map[keys + ':' + action]) {\n                delete _direct_map[keys + ':' + action];\n                this.bind(keys, function() {}, action);\n            }\n            return this;\n        },\n\n        /**\n         * triggers an event that has already been bound\n         *\n         * @param {string} keys\n         * @param {string=} action\n         * @returns void\n         */\n        trigger: function(keys, action) {\n            _direct_map[keys + ':' + action]();\n            return this;\n        },\n\n        /**\n         * resets the library back to its initial state.  this is useful\n         * if you want to clear out the current keyboard shortcuts and bind\n         * new ones - for example if you switch to another page\n         *\n         * @returns void\n         */\n        reset: function() {\n            _callbacks = {};\n            _direct_map = {};\n            return this;\n        },\n\n       /**\n        * should we stop this event before firing off callbacks\n        *\n        * @param {Event} e\n        * @param {Element} element\n        * @return {boolean}\n        */\n        stopCallback: function(e, element) {\n\n            // if the element has the class \"mousetrap\" then no need to stop\n            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n                return false;\n            }\n\n            // stop for input, select, and textarea\n            return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true');\n        }\n    };\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose mousetrap as an AMD module\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return Mousetrap; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // browserify support\n    if( true && module.exports) {\n        module.exports = Mousetrap;\n    }\n}) ();\n\n\n//# sourceURL=webpack:///./node_modules/br-mousetrap/mousetrap.js?");

/***/ }),

/***/ "./node_modules/eventedloop/lib/main.js":
/*!**********************************************!*\
  !*** ./node_modules/eventedloop/lib/main.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function() {\n    var root = this;\n    var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\tvar _ = __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\");\n\tvar intervalParser = /([0-9\\.]+)(ms|s|m|h)?/;\n\tvar root = global || window;\n\n\t// Lil bit of useful polyfill...\n\tif (typeof(Function.prototype.inherits) === 'undefined') {\n\t\tFunction.prototype.inherits = function(parent) {\n\t\t\tthis.prototype = Object.create(parent.prototype);\n\t\t};\n\t}\n\n\tif (typeof(Array.prototype.removeOne) === 'undefined') {\n\t\tArray.prototype.removeOne = function() {\n\t\t\tvar what, a = arguments, L = a.length, ax;\n\t\t\twhile (L && this.length) {\n\t\t\t\twhat = a[--L];\n\t\t\t\twhile ((ax = this.indexOf(what)) !== -1) {\n\t\t\t\t\treturn this.splice(ax, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction greatestCommonFactor(intervals) {\n\t\tvar sumOfModuli = 1;\n\t\tvar interval = _.min(intervals);\n\t\twhile (sumOfModuli !== 0) {\n\t\t\tsumOfModuli = _.reduce(intervals, function(memo, i){ return memo + (i % interval); }, 0);\n\t\t\tif (sumOfModuli !== 0) {\n\t\t\t\tinterval -= 10;\n\t\t\t}\n\t\t}\n\t\treturn interval;\n\t}\n\n\tfunction parseEvent(e) {\n\t\tvar intervalGroups = intervalParser.exec(e);\n\t\tif (!intervalGroups) {\n\t\t\tthrow new Error('I don\\'t understand that particular interval');\n\t\t}\n\t\tvar intervalAmount = +intervalGroups[1];\n\t\tvar intervalType = intervalGroups[2] || 'ms';\n\t\tif (intervalType === 's') {\n\t\t\tintervalAmount = intervalAmount * 1000;\n\t\t} else if (intervalType === 'm') {\n\t\t\tintervalAmount = intervalAmount * 1000 * 60;\n\t\t} else if (intervalType === 'h') {\n\t\t\tintervalAmount = intervalAmount * 1000 * 60 * 60;\n\t\t} else if (!!intervalType && intervalType !== 'ms') {\n\t\t\tthrow new Error('You can only specify intervals of ms, s, m, or h');\n\t\t}\n\t\tif (intervalAmount < 10 || intervalAmount % 10 !== 0) {\n\t\t\t// We only deal in 10's of milliseconds for simplicity\n\t\t\tthrow new Error('You can only specify 10s of milliseconds, trust me on this one');\n\t\t}\n\t\treturn {\n\t\t\tamount:intervalAmount,\n\t\t\ttype:intervalType\n\t\t};\n\t}\n\n\tfunction EventedLoop() {\n\t\tthis.intervalId = undefined;\n\t\tthis.intervalLength = undefined;\n\t\tthis.intervalsToEmit = {};\n\t\tthis.currentTick = 1;\n\t\tthis.maxTicks = 0;\n\t\tthis.listeningForFocus = false;\n\n\t\t// Private method\n\t\tvar determineIntervalLength = function () {\n\t\t\tvar potentialIntervalLength = greatestCommonFactor(_.keys(this.intervalsToEmit));\n\t\t\tvar changed = false;\n\n\t\t\tif (this.intervalLength) {\n\t\t\t\tif (potentialIntervalLength !== this.intervalLength) {\n\t\t\t\t\t// Looks like we need a new interval\n\t\t\t\t\tthis.intervalLength = potentialIntervalLength;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.intervalLength = potentialIntervalLength;\n\t\t\t}\n\n\t\t\tthis.maxTicks = _.max(_.map(_.keys(this.intervalsToEmit), function(a) { return +a; })) / this.intervalLength;\n\t\t\treturn changed;\n\t\t}.bind(this);\n\n\t\tthis.on('newListener', function (e) {\n\t\t\tif (e === 'removeListener' || e === 'newListener') return; // We don't care about that one\n\t\t\tvar intervalInfo = parseEvent(e);\n\t\t\tvar intervalAmount = intervalInfo.amount;\n\n\t\t\tthis.intervalsToEmit[+intervalAmount] = _.union(this.intervalsToEmit[+intervalAmount] || [], [e]);\n\t\t\t\n\t\t\tif (determineIntervalLength() && this.isStarted()) {\n\t\t\t\tthis.stop().start();\n\t\t\t}\n\t\t});\n\n\t\tthis.on('removeListener', function (e) {\n\t\t\tif (EventEmitter.listenerCount(this, e) > 0) return;\n\t\t\tvar intervalInfo = parseEvent(e);\n\t\t\tvar intervalAmount = intervalInfo.amount;\n\n\t\t\tvar removedEvent = this.intervalsToEmit[+intervalAmount].removeOne(e);\n\t\t\tif (this.intervalsToEmit[+intervalAmount].length === 0) {\n\t\t\t\tdelete this.intervalsToEmit[+intervalAmount];\n\t\t\t}\n\t\t\tconsole.log('Determining interval length after removal of', removedEvent);\n\t\t\tdetermineIntervalLength();\n\n\t\t\tif (determineIntervalLength() && this.isStarted()) {\n\t\t\t\tthis.stop().start();\n\t\t\t}\n\t\t});\n\t}\n\n\tEventedLoop.inherits(EventEmitter);\n\n\t// Public methods\n\tEventedLoop.prototype.tick = function () {\n\t\tvar milliseconds = this.currentTick * this.intervalLength;\n\t\t_.each(this.intervalsToEmit, function (events, key) {\n\t\t\tif (milliseconds % key === 0) {\n\t\t\t\t_.each(events, function(e) { this.emit(e, e, key); }.bind(this));\n\t\t\t}\n\t\t}.bind(this));\n\t\tthis.currentTick += 1;\n\t\tif (this.currentTick > this.maxTicks) {\n\t\t\tthis.currentTick = 1;\n\t\t}\n\t\treturn this;\n\t};\n\n\tEventedLoop.prototype.start = function () {\n\t\tif (!this.intervalLength) {\n\t\t\tthrow new Error('You haven\\'t specified any interval callbacks. Use EventedLoop.on(\\'500ms\\', function () { ... }) to do so, and then you can start');\n\t\t}\n\t\tif (this.intervalId) {\n\t\t\treturn console.log('No need to start the loop again, it\\'s already started.');\n\t\t}\n\n\t\tthis.intervalId = setInterval(this.tick.bind(this), this.intervalLength);\n\n\t\tif (root && !this.listeningForFocus && root.addEventListener) {\n\t\t\troot.addEventListener('focus', function() {\n\t\t\t\tthis.start();\n\t\t\t}.bind(this));\n\n\t\t\troot.addEventListener('blur', function() {\n\t\t\t\tthis.stop();\n\t\t\t}.bind(this));\n\n\t\t\tthis.listeningForFocus = true;\n\t\t}\n\t\treturn this;\n\t};\n\n\tEventedLoop.prototype.stop = function () {\n\t\tclearInterval(this.intervalId);\n\t\tthis.intervalId = undefined;\n\t\treturn this;\n\t};\n\n\tEventedLoop.prototype.isStarted = function () {\n\t\treturn !!this.intervalId;\n\t};\n\n\tEventedLoop.prototype.every = EventedLoop.prototype.on;\n\n    // Export the EventedLoop object for **Node.js** or other\n    // commonjs systems. Otherwise, add it as a global object to the root\n    if (true) {\n        if ( true && module.exports) {\n            exports = module.exports = EventedLoop;\n        }\n        exports.EventedLoop = EventedLoop;\n    }\n    if (typeof window !== 'undefined') {\n        window.EventedLoop = EventedLoop;\n    }\n}).call(this);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/eventedloop/lib/main.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.8 - 2016-09-30\n * http://hammerjs.github.io/\n *\n * Copyright (c)  Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) { \n'use strict';\n/**\n * @private\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n  return val1 === undefined ? val2 : val1;\n}\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n  var prefix = void 0;\n  var prop = void 0;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n\n  var i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = window.CSS && window.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = 'ontouchstart' in window;\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign = void 0;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i = void 0;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {number} -1 when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer = function () {\n  function Recognizer(options) {\n    classCallCheck(this, Recognizer);\n\n    this.options = assign$1({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  createClass(Recognizer, [{\n    key: 'set',\n    value: function set(options) {\n      assign$1(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    }\n\n    /**\n     * @private\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n\n  }, {\n    key: 'recognizeWith',\n    value: function recognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n\n  }, {\n    key: 'dropRecognizeWith',\n    value: function dropRecognizeWith(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    }\n\n    /**\n     * @private\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n\n  }, {\n    key: 'requireFailure',\n    value: function requireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n\n  }, {\n    key: 'dropRequireFailure',\n    value: function dropRequireFailure(otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * has require failures boolean\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'hasRequireFailures',\n    value: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    }\n\n    /**\n     * @private\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'canRecognizeWith',\n    value: function canRecognizeWith(otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    }\n\n    /**\n     * @private\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(input) {\n      var self = this;\n      var state = this.state;\n\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      }\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    }\n\n    /**\n     * @private\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n\n  }, {\n    key: 'tryEmit',\n    value: function tryEmit(input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    }\n\n    /**\n     * @private\n     * can we emit?\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'canEmit',\n    value: function canEmit() {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    }\n\n    /**\n     * @private\n     * update the recognizer\n     * @param {Object} inputData\n     */\n\n  }, {\n    key: 'recognize',\n    value: function recognize(inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign$1({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    }\n\n    /**\n     * @private\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {constant} STATE\n     */\n\n    /* jshint ignore:start */\n\n  }, {\n    key: 'process',\n    value: function process(inputData) {}\n    /* jshint ignore:end */\n\n    /**\n     * @private\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'getTouchAction',\n    value: function getTouchAction() {}\n\n    /**\n     * @private\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {}\n  }]);\n  return Recognizer;\n}();\n\nRecognizer.prototype.defaults = {};\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer = function (_Recognizer) {\n  inherits(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer() {\n    classCallCheck(this, AttrRecognizer);\n    return possibleConstructorReturn(this, (AttrRecognizer.__proto__ || Object.getPrototypeOf(AttrRecognizer)).apply(this, arguments));\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  createClass(AttrRecognizer, [{\n    key: 'attrTest',\n    value: function attrTest(input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    }\n\n    /**\n     * @private\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n\n  }, {\n    key: 'process',\n    value: function process(input) {\n      var state = this.state;\n      var eventType = input.eventType;\n\n\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  }]);\n  return AttrRecognizer;\n}(Recognizer);\n\nAttrRecognizer.prototype.defaults = {\n  /**\n   * @private\n   * @type {Number}\n   * @default 1\n   */\n  pointers: 1\n};\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer = function (_AttrRecognizer) {\n  inherits(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer() {\n    classCallCheck(this, RotateRecognizer);\n    return possibleConstructorReturn(this, (RotateRecognizer.__proto__ || Object.getPrototypeOf(RotateRecognizer)).apply(this, arguments));\n  }\n\n  createClass(RotateRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    }\n  }, {\n    key: 'attrTest',\n    value: function attrTest(input) {\n      return get(RotateRecognizer.prototype.__proto__ || Object.getPrototypeOf(RotateRecognizer.prototype), 'attrTest', this).call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  }]);\n  return RotateRecognizer;\n}(AttrRecognizer);\n\nRotateRecognizer.prototype.defaults = {\n  event: 'rotate',\n  threshold: 0,\n  pointers: 2\n};\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer = function (_AttrRecognizer) {\n  inherits(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer() {\n    classCallCheck(this, PinchRecognizer);\n    return possibleConstructorReturn(this, (PinchRecognizer.__proto__ || Object.getPrototypeOf(PinchRecognizer)).apply(this, arguments));\n  }\n\n  createClass(PinchRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      return [TOUCH_ACTION_NONE];\n    }\n  }, {\n    key: 'attrTest',\n    value: function attrTest(input) {\n      return get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), 'attrTest', this).call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  }, {\n    key: 'emit',\n    value: function emit(input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n      get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), 'emit', this).call(this, input);\n    }\n  }]);\n  return PinchRecognizer;\n}(AttrRecognizer);\n\nPinchRecognizer.prototype.defaults = {\n  event: 'pinch',\n  threshold: 0,\n  pointers: 2\n};\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer = function (_AttrRecognizer) {\n  inherits(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer() {\n    classCallCheck(this, PanRecognizer);\n\n    var _this = possibleConstructorReturn(this, (PanRecognizer.__proto__ || Object.getPrototypeOf(PanRecognizer)).apply(this, arguments));\n\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  createClass(PanRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      var direction = this.options.direction;\n\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    }\n  }, {\n    key: 'directionTest',\n    value: function directionTest(input) {\n      var options = this.options;\n\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x !== this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y !== this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    }\n  }, {\n    key: 'attrTest',\n    value: function attrTest(input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n      this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    }\n  }, {\n    key: 'emit',\n    value: function emit(input) {\n\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n      get(PanRecognizer.prototype.__proto__ || Object.getPrototypeOf(PanRecognizer.prototype), 'emit', this).call(this, input);\n    }\n  }]);\n  return PanRecognizer;\n}(AttrRecognizer);\n\nPanRecognizer.prototype.defaults = {\n  event: 'pan',\n  threshold: 10,\n  pointers: 1,\n  direction: DIRECTION_ALL\n};\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer = function (_AttrRecognizer) {\n  inherits(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer() {\n    classCallCheck(this, SwipeRecognizer);\n    return possibleConstructorReturn(this, (SwipeRecognizer.__proto__ || Object.getPrototypeOf(SwipeRecognizer)).apply(this, arguments));\n  }\n\n  createClass(SwipeRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    }\n  }, {\n    key: 'attrTest',\n    value: function attrTest(input) {\n      var direction = this.options.direction;\n\n      var velocity = void 0;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return get(SwipeRecognizer.prototype.__proto__ || Object.getPrototypeOf(SwipeRecognizer.prototype), 'attrTest', this).call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    }\n  }, {\n    key: 'emit',\n    value: function emit(input) {\n      var direction = directionStr(input.offsetDirection);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  }]);\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\nSwipeRecognizer.prototype.defaults = {\n  event: 'swipe',\n  threshold: 10,\n  velocity: 0.3,\n  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n  pointers: 1\n};\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n  return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer = function (_Recognizer) {\n  inherits(TapRecognizer, _Recognizer);\n\n  function TapRecognizer() {\n    classCallCheck(this, TapRecognizer);\n\n    // previous time and center,\n    // used for tap counting\n    var _this = possibleConstructorReturn(this, (TapRecognizer.__proto__ || Object.getPrototypeOf(TapRecognizer)).apply(this, arguments));\n\n    _this.pTime = false;\n    _this.pCenter = false;\n\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  createClass(TapRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      return [TOUCH_ACTION_MANIPULATION];\n    }\n  }, {\n    key: 'process',\n    value: function process(input) {\n      var _this2 = this;\n\n      var options = this.options;\n\n\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType !== INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              _this2.state = STATE_RECOGNIZED;\n              _this2.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    }\n  }, {\n    key: 'failTimeout',\n    value: function failTimeout() {\n      var _this3 = this;\n\n      this._timer = setTimeoutContext(function () {\n        _this3.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      clearTimeout(this._timer);\n    }\n  }, {\n    key: 'emit',\n    value: function emit() {\n      if (this.state === STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  }]);\n  return TapRecognizer;\n}(Recognizer);\n\nTapRecognizer.prototype.defaults = {\n  event: 'tap',\n  pointers: 1,\n  taps: 1,\n  interval: 300, // max time between the multi-tap taps\n  time: 250, // max time of the pointer to be down (like finger on the screen)\n  threshold: 9, // a minimal movement is ok, but keep it low\n  posThreshold: 10 // a multi-tap can be a bit off the initial position\n};\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer = function (_Recognizer) {\n  inherits(PressRecognizer, _Recognizer);\n\n  function PressRecognizer() {\n    classCallCheck(this, PressRecognizer);\n\n    var _this = possibleConstructorReturn(this, (PressRecognizer.__proto__ || Object.getPrototypeOf(PressRecognizer)).apply(this, arguments));\n\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  createClass(PressRecognizer, [{\n    key: 'getTouchAction',\n    value: function getTouchAction() {\n      return [TOUCH_ACTION_AUTO];\n    }\n  }, {\n    key: 'process',\n    value: function process(input) {\n      var _this2 = this;\n\n      var options = this.options;\n\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          _this2.state = STATE_RECOGNIZED;\n          _this2.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      clearTimeout(this._timer);\n    }\n  }, {\n    key: 'emit',\n    value: function emit(input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  }]);\n  return PressRecognizer;\n}(Recognizer);\n\nPressRecognizer.prototype.defaults = {\n  event: 'press',\n  pointers: 1,\n  time: 251, // minimal time of the pointer to be pressed\n  threshold: 9 // a minimal movement is ok, but keep it low\n};\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction = function () {\n  function TouchAction(manager, value) {\n    classCallCheck(this, TouchAction);\n\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  createClass(TouchAction, [{\n    key: 'set',\n    value: function set(value) {\n      // find out the touch-action by the event handlers\n      if (value === TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    }\n\n    /**\n     * @private\n     * just re-set the touchAction value\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      this.set(this.manager.options.touchAction);\n    }\n\n    /**\n     * @private\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n\n  }, {\n    key: 'compute',\n    value: function compute() {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    }\n\n    /**\n     * @private\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n\n  }, {\n    key: 'preventDefaults',\n    value: function preventDefaults(input) {\n      var srcEvent = input.srcEvent;\n\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        // do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    }\n\n    /**\n     * @private\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n\n  }, {\n    key: 'preventSrc',\n    value: function preventSrc(srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  }]);\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity = void 0;\n  var velocityX = void 0;\n  var velocityY = void 0;\n  var direction = void 0;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length;\n\n  // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput;\n  var firstMultiple = session.firstMultiple;\n\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n\n  computeIntervalInputData(session, input);\n\n  // find the correct target\n  var target = manager.element;\n  if (hasParent(input.srcEvent.target, target)) {\n    target = input.srcEvent.target;\n  }\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input = function () {\n  function Input(manager, callback) {\n    classCallCheck(this, Input);\n\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  createClass(Input, [{\n    key: 'handler',\n    value: function handler() {}\n\n    /**\n     * @private\n     * bind the events\n     */\n\n  }, {\n    key: 'init',\n    value: function init() {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n\n    /**\n     * @private\n     * unbind the events\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  }]);\n  return Input;\n}();\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\nvar PointerEventInput = function (_Input) {\n  inherits(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    classCallCheck(this, PointerEventInput);\n\n    var _this = possibleConstructorReturn(this, (PointerEventInput.__proto__ || Object.getPrototypeOf(PointerEventInput)).apply(this, arguments));\n\n    _this.evEl = POINTER_ELEMENT_EVENTS;\n    _this.evWin = POINTER_WINDOW_EVENTS;\n\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  createClass(PointerEventInput, [{\n    key: 'handler',\n    value: function handler(ev) {\n      var store = this.store;\n\n      var removePointer = false;\n\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n      var isTouch = pointerType === INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  }]);\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray$1(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = function (_Input) {\n  inherits(TouchInput, _Input);\n\n  function TouchInput() {\n    classCallCheck(this, TouchInput);\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    TouchInput.prototype.targetIds = {};\n\n    var _this = possibleConstructorReturn(this, (TouchInput.__proto__ || Object.getPrototypeOf(TouchInput)).apply(this, arguments));\n\n    _this.evTarget = TOUCH_TARGET_EVENTS;\n    _this.targetIds = {};\n    return _this;\n  }\n\n  createClass(TouchInput, [{\n    key: 'handler',\n    value: function handler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  }]);\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray$1(ev.touches);\n  var targetIds = this.targetIds;\n\n  // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i = void 0;\n  var targetTouches = void 0;\n  var changedTouches = toArray$1(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target;\n\n  // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  });\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = function (_Input) {\n  inherits(MouseInput, _Input);\n\n  function MouseInput() {\n    classCallCheck(this, MouseInput);\n\n    var _this = possibleConstructorReturn(this, (MouseInput.__proto__ || Object.getPrototypeOf(MouseInput)).apply(this, arguments));\n\n    _this.evEl = MOUSE_ELEMENT_EVENTS;\n    _this.evWin = MOUSE_WINDOW_EVENTS;\n\n    _this.pressed = false; // mousedown state\n    return _this;\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  createClass(MouseInput, [{\n    key: 'handler',\n    value: function handler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  }]);\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nvar TouchMouseInput = function (_Input) {\n  inherits(TouchMouseInput, _Input);\n\n  function TouchMouseInput() {\n    classCallCheck(this, TouchMouseInput);\n\n    var _this = possibleConstructorReturn(this, (TouchMouseInput.__proto__ || Object.getPrototypeOf(TouchMouseInput)).apply(this, arguments));\n\n    var handler = bindFn(_this.handler, _this);\n    _this.touch = new TouchInput(_this.manager, handler);\n    _this.mouse = new MouseInput(_this.manager, handler);\n\n    _this.primaryTouch = null;\n    _this.lastTouches = [];\n    return _this;\n  }\n\n  /**\n   * @private\n   * handle mouse and touch events\n   * @param {Hammer} manager\n   * @param {String} inputEvent\n   * @param {Object} inputData\n   */\n\n\n  createClass(TouchMouseInput, [{\n    key: 'handler',\n    value: function handler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n      var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      }\n\n      // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    }\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  }]);\n  return TouchMouseInput;\n}(Input);\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction setLastTouch(eventData) {\n  var _this2 = this;\n\n  var _eventData$changedPoi = slicedToArray(eventData.changedPointers, 1);\n\n  var touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    (function () {\n      var lastTouch = { x: touch.clientX, y: touch.clientY };\n      _this2.lastTouches.push(lastTouch);\n      var lts = _this2.lastTouches;\n      var removeLastTouch = function removeLastTouch() {\n        var i = lts.indexOf(lastTouch);\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    })();\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n  var Type = void 0;\n  // let inputClass = manager.options.inputClass;\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new Type(manager, inputHandler);\n}\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Manager = function () {\n  function Manager(element, options) {\n    var _this = this;\n\n    classCallCheck(this, Manager);\n\n    this.options = assign$1({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  createClass(Manager, [{\n    key: 'set',\n    value: function set(options) {\n      assign$1(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    }\n\n    /**\n     * @private\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop(force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    }\n\n    /**\n     * @private\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n\n  }, {\n    key: 'recognize',\n    value: function recognize(inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n\n      var recognizer = void 0;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer === curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    }\n\n    /**\n     * @private\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event === recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @private add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n\n  }, {\n    key: 'add',\n    value: function add(recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n\n      this.touchAction.update();\n      return recognizer;\n    }\n\n    /**\n     * @private\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer);\n\n      // let's make sure this recognizer exists\n      if (recognizer) {\n        var recognizers = this.recognizers;\n\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * @private\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n\n  }, {\n    key: 'on',\n    value: function on(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    }\n\n    /**\n     * @private unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n\n  }, {\n    key: 'off',\n    value: function off(events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * @private emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit(event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    }\n\n    /**\n     * @private\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.element && toggleCssProps(this, false);\n\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  }]);\n  return Manager;\n}();\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n  var prop = void 0;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || '';\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent('Event');\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer = function Hammer(element, options) {\n  classCallCheck(this, Hammer);\n\n  options = options || {};\n  options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n  return new Manager(element, options);\n};\n\nHammer.VERSION = '2.0.8';\n\n/**\n * @private\n * default settings\n * @namespace\n */\nHammer.defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Default recognizer setup when calling `Hammer()`\n   * When creating a new Manager these will be skipped.\n   * @type {Array}\n   */\n  preset: [\n  // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n  [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: 'none',\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: 'none',\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: 'none',\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: 'none',\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: 'none',\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = function (_Input) {\n  inherits(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    classCallCheck(this, SingleTouchInput);\n\n    var _this = possibleConstructorReturn(this, (SingleTouchInput.__proto__ || Object.getPrototypeOf(SingleTouchInput)).apply(this, arguments));\n\n    _this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    _this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this.started = false;\n\n    Input.apply(_this, arguments);\n    return _this;\n  }\n\n  createClass(SingleTouchInput, [{\n    key: 'handler',\n    value: function handler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  }]);\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray$1(ev.touches);\n  var changed = toArray$1(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP = void 0;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nassign$1(Hammer, {\n  INPUT_START: INPUT_START,\n  INPUT_MOVE: INPUT_MOVE,\n  INPUT_END: INPUT_END,\n  INPUT_CANCEL: INPUT_CANCEL,\n\n  STATE_POSSIBLE: STATE_POSSIBLE,\n  STATE_BEGAN: STATE_BEGAN,\n  STATE_CHANGED: STATE_CHANGED,\n  STATE_ENDED: STATE_ENDED,\n  STATE_RECOGNIZED: STATE_RECOGNIZED,\n  STATE_CANCELLED: STATE_CANCELLED,\n  STATE_FAILED: STATE_FAILED,\n\n  DIRECTION_NONE: DIRECTION_NONE,\n  DIRECTION_LEFT: DIRECTION_LEFT,\n  DIRECTION_RIGHT: DIRECTION_RIGHT,\n  DIRECTION_UP: DIRECTION_UP,\n  DIRECTION_DOWN: DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n  DIRECTION_ALL: DIRECTION_ALL,\n\n  Manager: Manager,\n  Input: Input,\n  TouchAction: TouchAction,\n\n  TouchInput: TouchInput,\n  MouseInput: MouseInput,\n  PointerEventInput: PointerEventInput,\n  TouchMouseInput: TouchMouseInput,\n  SingleTouchInput: SingleTouchInput,\n\n  Recognizer: Recognizer,\n  AttrRecognizer: AttrRecognizer,\n  Tap: TapRecognizer,\n  Pan: PanRecognizer,\n  Swipe: SwipeRecognizer,\n  Pinch: PinchRecognizer,\n  Rotate: RotateRecognizer,\n  Press: PressRecognizer,\n\n  on: addEventListeners,\n  off: removeEventListeners,\n  each: each,\n  merge: merge,\n  extend: extend,\n  assign: assign$1,\n  inherit: inherit,\n  bindFn: bindFn,\n  prefixed: prefixed,\n  toArray: toArray$1,\n  inArray: inArray,\n  uniqueArray: uniqueArray,\n  splitStr: splitStr,\n  boolOrFn: boolOrFn,\n  hasParent: hasParent,\n  addEventListeners: addEventListeners,\n  removeEventListeners: removeEventListeners\n});\n\n/* jshint ignore:start */\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return Hammer;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n/* jshint ignore:end */\n})(window, document, 'Hammer');\n\n\n//# sourceURL=webpack:///./node_modules/hammerjs/hammer.js?");

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if ( true && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {}\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (true) {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/underscore/underscore.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });